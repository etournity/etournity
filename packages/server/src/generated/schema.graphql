### This file was generated by Nexus Schema
### Do not make changes to this file directly


input BestOfInput {
  bestOf: Int
  roundId: String
}

"""
The `BigInt` scalar type represents non-fractional signed whole numeric values.
@see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt
"""
scalar BigInt

"""The `Byte` scalar type represents byte value as a Buffer"""
scalar Bytes

type ChatMessage {
  author: User!
  authorId: String!
  chatRoom: ChatRoom!
  chatRoomId: String!
  content: String!
  createdAt: DateTime!
  id: ID!
}

type ChatRoom {
  archivedAt: DateTime
  id: ID!
  members: [User!]!
  messages: [ChatMessage!]!
  name: String!
  tournament: Tournament
  tournamentId: String
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

"""An arbitrary-precision Decimal type"""
scalar Decimal

type Game {
  gameUsers: [GameUser!]!
  homepage: String
  id: ID!
  image: Image
  supported: Boolean!
  title: String!
  tournaments: [Tournament!]!
  verified: Boolean!
}

type GameMode {
  id: ID!
  name: String!
  teamSize: Int
}

enum GameStatus {
  CONFLICT
  MANUAL_EDIT
  SUCCESS
  WAITING
}

type GameUser {
  elo: Int!
  game: Game!
  gameId: String!
  id: ID!
  inGameName: String!
  user: User
}

type Image {
  contentType: String!
  game: Game
  id: ID!
  name: String!
  secret: String!
  size: Int!
  url: String!
}

"""
The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar Json @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

type Language {
  code: ID!
  name: String!
}

type Match {
  gameLobbyCode: String
  id: ID!
  inGame: [String!]!
  matchGames: [MatchGame!]!
  noShowTimer: DateTime
  number: Int!
  opponents: [Team!]!
  readyChecks: [ReadyCheck!]!
  round: Round
  status: MatchStatus!
  supportLink: String
  tickets: [Ticket!]!
}

type MatchGame {
  """The final, confirmed results of the game"""
  finalResults: [Result]!
  id: ID!
  match: Match!
  matchId: String!
  number: Int!
  result: [Result!]!
  status: GameStatus!
  submissions: [Submission!]!

  """
  Returns true if all scores match, false if they don't and null if submissions are missing
  """
  submissionsEqual: Boolean
}

input MatchResultInput {
  matchGameId: ID!
  results: [ResultCreateInput]
}

enum MatchStatus {
  DONE
  ERROR
  GAME_PHASE
  NO_SHOW
  PREP_PHASE
  SCHEDULED
  STARTED
}

type Mutation {
  addLobbyCode(lobbycode: String!, matchId: ID!): Match
  addOpponent(matchId: ID!, teamId: ID!): Match!
  addParticipant(elo: Int, name: String, requestingMod: Boolean, tournamentId: ID!): Participant
  addToInGame(matchId: ID!): Match
  changeStatus(matchId: ID!, status: MatchStatus!): Match!
  checkinParticipant(tournamentId: ID!): Participant
  closeTicket(ticketId: ID!, verdict: String): Ticket
  createChatMessage(chatRoomId: String!, content: String!): ChatMessage
  createGame(homepage: String, title: String!): Game!
  createMatch(opponentIds: [ID!]!, roundId: ID!): Match!
  createMatchGame(matchId: ID!): MatchGame
  createOrUpdateGameUser(elo: Int!, gameId: ID!, inGameName: String!, userId: ID!): GameUser
  createReadyCheck(matchId: ID!, participantId: ID!): ReadyCheck

  """Create a copy of the entire database"""
  createSavestate(title: String): String
  createSubmissions(data: [SubmissionCreateInput!]): [Submission]
  createSystemTicket(matchBlocked: Boolean, matchId: ID, message: String, reportedId: ID, ticketType: TicketType!, tournamentId: ID): Ticket!
  createTeam(name: String!, participantIds: [ID!], tournamentId: ID!): Team
  createTicket(matchBlocked: Boolean, message: String, reportedId: ID, reporterId: ID!, ticketType: TicketType!, tournamentId: ID): Ticket!
  createTournament(data: TournamentCreateInput!): Tournament
  deleteMatch(matchId: ID!): Match

  """Delete a database copy"""
  deleteSavestate(title: String!): Boolean
  deleteTicket(ticketId: ID!): Ticket
  deleteTournament(tournamentId: ID!): Tournament
  generateBrackets(algorithm: String!, tournamentId: ID!): [[[String]!]!]!
  kickParticipant(participantId: ID!): Participant
  publishBrackets(bestOfs: [BestOfInput]!, publishInput: [[[String]]!]!, tournamentId: ID!): [Round]
  removeOpponent(matchId: ID!, teamId: ID!): Match!
  removeParticipant(tournamentId: ID!, userId: ID): Participant
  resetMatch(matchId: ID!, ticketId: ID, verdict: String): Match
  resolvePlayerReport(participantId: ID!, ticketId: ID!, verdict: String): Ticket

  """Restore a database copy"""
  restoreSavestate(title: String!): String
  setCheckIn(endTime: DateTime, startTime: DateTime, tournamentId: ID!): Tournament
  setHideDisclaimer(hideDisclaimer: Boolean!): User
  setMatchGameStatus(matchGameId: ID!, status: GameStatus): MatchGame
  setMatchResults(matchGameResults: [MatchResultInput!]!, matchId: ID!, ticketId: ID, verdict: String): Match
  setMatchWinner(matchId: ID!, ticketId: ID, verdict: String, winnerId: ID!): Match
  setRoundStatus(locked: Boolean, roundId: ID!, status: RoundStatus): Round
  setStartTime(startTime: DateTime, tournamentId: ID!): Tournament
  setTicketAssignee(assigneeId: ID!, ticketId: ID!): Ticket!
  setTournamentStatus(status: TournamentStatus!, ticketId: ID, tournamentId: ID!, verdict: String): Tournament
  setUsername(name: String!): User
  updateElo(elo: Int!, id: ID!, tournamentId: ID!): GameUser
  updateParticipantRoles(addRoles: [ParticipantRoleType!], deniedMod: Boolean, participantId: ID!, removeRoles: [ParticipantRoleType!], ticketId: ID, verdict: String): Participant
  updateSeed(seed: Int!, teamId: ID!): Team
  updateTournament(data: TournamentCreateInput!, tournamentId: ID!): Tournament
}

type Participant {
  checkedInAt: DateTime
  deniedMod: Boolean!
  id: ID!
  isCheckedIn: Boolean
  isCreator(matchId: ID!): Boolean
  isCurrentUser: Boolean
  isHost: Boolean
  isModerator: Boolean
  isPlayer: Boolean
  isReady(matchId: ID!): Boolean
  isRegistered: Boolean
  kicked: Boolean!
  readyChecks: [ReadyCheck!]!
  registeredAt: DateTime
  requestingMod: Boolean!
  roles: [ParticipantRole!]!
  team: Team
  teamId: String
  tournament: Tournament
  tournamentId: String
  user: User!
  userId: String!
}

type ParticipantRole {
  id: ID!
  participant: Participant!
  participantId: String!
  type: ParticipantRoleType!
}

enum ParticipantRoleType {
  ADMIN
  HOST
  MODERATOR
  PLAYER
}

type Platform {
  code: ID!
  name: String!
}

type Query {
  chatRoomMessages(chatRoomId: ID!): [ChatMessage!]!
  games: [Game!]!
  gameUsers: [GameUser]
  isCheckedIn(tournamentId: ID!): Boolean
  isRegistered(tournamentId: ID!): Boolean
  languages: [Language]
  match(matchId: ID!): Match
  matchesInTournament(tournamentId: ID!): [Match!]!
  me: User
  participants: [Participant!]!
  participantsFromTournament(tournamentId: ID!): [Participant!]!
  platforms: [Platform!]!
  playersFromTournament(tournamentId: ID!): [Participant!]!
  regions: [Region!]!
  relatedChatRooms: [ChatRoom!]!
  relatedTickets: [Ticket!]
  savestates: [String!]!
  staffFromTournament(tournamentId: ID!): [Participant!]!
  team(teamId: ID!): Team
  tickets: [Ticket]
  tournament(tournamentId: ID!): Tournament
  tournaments(
    """Filter returned tournaments by users participation or all if omitted."""
    userHasParticipantRoles: [ParticipantRoleType!]
  ): [Tournament]
  tournamentStages(tournamentId: ID!): [Stage!]!
  tournamentTickets(tournamentId: ID!): [Ticket!]!
  user(userId: ID!): User
  userAccounts: [UserAccount]
  userParticipants: [Participant]
  users: [User]
}

type ReadyCheck {
  checkedInAt: DateTime!
  id: ID!
  lobbyRole: String!
  match: Match!
  matchId: String!
  participant: Participant!
}

type Region {
  code: ID!
  name: String!
}

type Result {
  id: ID!
  score: Int!
  submission: Submission
  submissionId: String
  team: Team!
  teamId: String!
}

input ResultCreateInput {
  score: Int!
  teamId: ID!
}

type Round {
  completedMatches: Int!
  format: Int!
  id: ID!
  locked: Boolean!
  matches: [Match!]!
  number: Int!
  playersInRound: Int
  stage: Stage
  stageId: String
  status: RoundStatus!
  title: String
}

enum RoundStatus {
  ACTIVE
  COMPLETED
  UPCOMING
}

type Stage {
  id: ID!
  number: Int!
  rounds: [Round!]!
  title: String
  tournament: Tournament!
  tournamentId: String!
  type: StageType!
}

enum StageType {
  SINGLE
}

type Submission {
  id: ID!
  matchGame: MatchGame
  matchGameId: String
  resubmitted: Boolean!
  results: [Result!]!
  team: Team!
  teamId: String!
}

input SubmissionCreateInput {
  matchGameId: ID!
  number: Int
  results: [ResultCreateInput!]!
  teamId: ID!
}

type Subscription {
  chatRoomChanged(actions: [String!], chatRoomId: ID!): ChatRoom
  matchChanged(actions: [String!], matchId: ID!): Match
  ticketChanged(actions: [String], ticketId: ID, tournamentId: ID): Ticket
  tournamentChanged(actions: [String], tournamentId: ID!): Tournament
}

type Team {
  allScoresSubmitted(matchId: ID!): Boolean
  avatar: String
  averageElo: Float
  id: ID!
  kicked: Boolean
  leader: Participant
  leaderId: String
  matches: [Match!]!
  name: String!
  participants: [Participant!]!
  participantsReady(matchId: ID!): Int
  readyChecks: [ReadyCheck!]!
  seed: Int
}

type Ticket {
  assignee: User
  id: ID!
  match: Match
  matchBlocked: Boolean
  matchId: String
  message: String
  number: Int
  reported: User
  reporter: User
  resolved: Boolean!
  tournament: Tournament
  tournamentId: String
  type: TicketType!
  verdict: String
}

enum TicketType {
  GAME_ISSUE
  PLAYER_NOT_RESPONDING
  PLAYER_REPORT
  SCORE_CONFLICT
  SITE_ISSUE
}

type Tournament {
  activeRound: Round
  chatRoom: ChatRoom
  checkinEnd: DateTime
  checkinStart: DateTime
  completedRounds: Int!
  createdAt: DateTime!
  date: DateTime!
  description: String
  discordLink: String
  game: Game!
  gameId: String!
  gameMode: GameMode!
  gameModeId: String!
  gameUser: GameUser
  hostUser: User!
  id: ID!
  language: Language
  maxPlayers: Int
  noShow: Int!
  participants: [Participant!]!
  platforms: [Platform!]!
  players: [Participant]
  playersCount: Int
  prizePool: String
  publishedAt: DateTime
  region: Region
  roundsCount: Int
  rules: String!
  staff: [Participant]
  staffCount: Int
  stages: [Stage!]!
  status: TournamentStatus!
  streamLink: String
  supportLink: String
  tickets: [Ticket!]!
  title: String!
  unassignedTickets: Int
  updatedAt: DateTime!
  userRoles: [ParticipantRoleType!]

  """
  Returns the team, that won the last match of the tournament (if possible) or null. Match counts as won if the combined scores are higher than (round.format/2)
  """
  winnerTeam: Team
}

input TournamentCreateInput {
  checkinEnd: DateTime
  checkinStart: DateTime
  date: DateTime!
  description: String!
  gameId: String!
  gameModeId: ID!
  language: ID
  maxPlayers: Int!
  noShow: Int!
  platforms: [ID!]!
  prizePool: String
  region: ID
  rules: String!
  streamLink: String
  supportLink: String
  title: String!
  type: StageType!
}

enum TournamentStatus {
  CANCELLED
  DRAFT
  ERROR
  FINISHED
  PUBLISHED
  STARTED
}

type User {
  createdAt: DateTime!
  currentHost: Participant
  currentMatch: Match
  currentParticipant: Participant
  displayName: String!
  gameUserFromTournament(tournamentId: ID!): GameUser
  gameUsers: [GameUser!]!
  hideAlphaDisclaimer: Boolean!
  id: ID!
  linkedAccounts: [UserAccount!]!
  participantFromTournament(tournamentId: ID!): Participant
  participants: [Participant!]!
  permissions: [String!]!
  roles: [String!]!
  updatedAt: DateTime!
}

type UserAccount {
  accessToken: String!
  avatar: String
  discriminator: String!
  email: String
  fetchedAt: String!
  id: ID!
  locale: String!
  mfaEnabled: Boolean!
  owner: User!
  provider: String!
  refreshToken: String!
  userId: String!
  username: String!
  verified: Boolean!
}
